######################################################################
# This file copyright the Georgia Institute of Technology
#
# Permission is given to students to use or modify this file (only)
# to work on their assignments.
#
# You may NOT publish this file or make it available to others not in
# the course.
#
######################################################################

import unittest
import multiprocessing as mproc
import traceback
import sys
import copy
import io
import math
import random
from state import State

try:
    from warehouse import DeliveryPlanner_PartB, who_am_i
    studentExc = None
except Exception as e:
    studentExc = traceback.format_exc()
    
########################################################################
# For debugging this flag can be set to True to print state 
# which could result in a timeout
########################################################################
VERBOSE_FLAG = False

########################################################################
# For visualization this flag can be set to True to display a GUI
# which could result in a timeout, but useful for debugging
# Note that enabling this will also enable DEBUGGING_SINGLE_PROCESS
########################################################################
VISUALIZE_FLAG = False

########################################################################
# For debugging set the time limit to a big number (like 600 or more)
########################################################################
TIME_LIMIT = 5  # seconds

########################################################################
# If your debugger does not handle multiprocess debugging very easily
# then when debugging set the following flag true.
########################################################################
DEBUGGING_SINGLE_PROCESS = False

# Necessary for GUI visualization, don't modify these lines
if VISUALIZE_FLAG:
    from visualizer import GUI
DEBUGGING_SINGLE_PROCESS = True if VISUALIZE_FLAG else DEBUGGING_SINGLE_PROCESS


def truncate_output( s, max_len = 2000 ):
    if len(s) > max_len:
        return s[:max_len-70] + "\n***************** OUTPUT TRUNCATED DUE TO EXCESSIVE LENGTH!**************\n"
    else:
        return s


DIRECTIONS = 'n,nw,w,sw,s,se,e,ne'.split(',')
DIRECTION_INDICES = {direction: index for index, direction in enumerate(DIRECTIONS)}
DELTA_DIRECTIONS = [
    (-1, 0),
    (-1, -1),
    (0, -1),
    (1, -1),
    (1, 0),
    (1, 1),
    (0, 1),
    (-1, 1),
]

MOVE_DIRECTIONS = {"n":(-1,0),"ne":(-1,1),"e":(0,1),"se":(1,1),
                    "s":(1,0),"sw":(1,-1),"w":(0,-1),"nw":(-1,-1)}

class Submission:
    """Student Submission.

    Attributes:
        submission_score(Queue): Student score of last executed plan.
        submission_error(Queue): Error messages generated during last executed plan.
    """
    def __init__(self, fout=None):

        if DEBUGGING_SINGLE_PROCESS:
            import queue
            self.submission_score = queue.Queue(1)
            self.submission_error = queue.Queue(1)
            self.logmsgs = queue.Queue(1)
        else:
            self.submission_score = mproc.Manager().Queue(1)
            self.submission_error = mproc.Manager().Queue(1)
            self.logmsgs = mproc.Manager().Queue(1)

        self.fout = io.StringIO()

    def log(self, s):
        self.fout.write(s + '\n')

    def _reset(self):
        """Reset submission results.
        """
        while not self.submission_score.empty():
            self.submission_score.get()

        while not self.submission_error.empty():
            self.submission_error.get()

        while not self.logmsgs.empty():
            self.logmsgs.get()

    def _get_actions_from_policy(self, policy, robot_initial_position):
        """ Extract the set of actions from the policy generated by
            the student planner

        Args:
            policy(list(list)): the warehouse policy
            robot_initial_position (i,j): initial robot_position
        """

        i2,j2 = robot_initial_position
        li,lj = i2,j2
        moves = []

        # if there is a policy start moving through it from the initial
        # robot position
        if policy and len(policy[0]) > 0:
            # work through the policy but in case it never identifies
            # a position from which to lift the box, limit the total
            # possible moves

            # check that there is a valid policy defined at the initial robot location
            if not( 0 <= i2 < len(policy)) or not ( j2 < len( policy[0]) ) :
                raise Exception(f'No action provided in policy at location ({i2},{j2})')

            while len( moves ) < 1000:
                i,j = i2,j2
                
                if not isinstance(policy[i][j],str):
                    raise Exception(f'Policy action must be a string.  Received: {policy[i][j]} at location ({li},{lj})')
                elif len(policy[i][j]) == 0:
                    raise Exception(f'No action provided in policy at location ({li},{lj})')
                elif '-1' in policy[i][j]:
                    # Note to self, the initial robot location will never be on an actual wall
                    raise Exception(f"Invalid policy action ('-1') at location ({li},{lj}),  See PDF for valid actions (ie. move, lift, or down)")
    
                # extract the action
                action = policy[i][j].split()
    
                # append it to the list of moves
                moves.append( policy[i][j] )

                # check for the "final" move which will be a lift or down command
                if 'lift' in policy[i][j] or 'down' in policy[i][j] :
                    break

                # increment the robot position according to the policy
                i2,j2 = i + MOVE_DIRECTIONS[action[1]][0], \
                        j + MOVE_DIRECTIONS[action[1]][1]

                # make sure this position exists in the policy
                if not( 0 <= i2 < len(policy)) or not ( j2 < len( policy[0]) ) :
                    raise Exception('Error in _get_actions_from_policy(): trying to move outside of warehouse at (i,j)=({},{}), action = {})'.format(i,j,policy[i][j]))  

                li,lj = i,j

 
        else:
            if not policy:
                raise Exception('No policy provided! The robot needs a policy in order to take actions.')
            else:
                raise Exception('The provided policy is empty, the robot was hoping to receive some guidance on the actions it should take!')
        
        return moves
        
            
    def execute_student_plan(self, test_case, warehouse, warehouse_cost, robot_initial_position, boxes_todo):
        """Execute student plan and store results in submission.

        Args:
            warehouse(list(list)): the warehouse map to test against.
            warehouse_cost(list(list)): integer costs for each warehouse position
            robot_initial_position (i,j): initial position of robot 
            boxes_todo(list): the order of boxes to deliver.
        """
        self._reset()

        state = State(warehouse, warehouse_cost, robot_initial_position)
        quit_signal = None
        try:
            student_planner = DeliveryPlanner_PartB(copy.deepcopy(warehouse),
                                                    copy.deepcopy(warehouse_cost),
                                                    copy.deepcopy(boxes_todo))
            search_policy, deliver_policy = student_planner.generate_policies(debug=VERBOSE_FLAG)

            # First follow the policy from wherever the robot has been dropped to find the box
            search_actions = self._get_actions_from_policy( search_policy, robot_initial_position )

            if VERBOSE_FLAG:
                print("Search actions: ")
                for i in range(len(search_actions )):
                    print( search_actions[i])

            if VISUALIZE_FLAG:
                gui = GUI('B', test_case, state, len(search_actions))
                quit_signal = gui.quit_signal
                if quit_signal:
                    self.log('GUI received quit signal before executing any actions.')
                    search_actions = []
                prev_loc = state.robot_position
                prev_box_locs = copy.deepcopy(state.boxes)

            for action in search_actions:
                if VERBOSE_FLAG:
                    state.print_to_console( self.fout )

                if isinstance(action,str) and len(action) > 0:
                    state.update_according_to(action)

                if VISUALIZE_FLAG:
                    gui.update(state, action, prev_loc, prev_box_locs)
                    quit_signal = gui.quit_signal
                    if quit_signal:
                        self.log('GUI received quit signal.')
                        break
                    prev_loc = state.robot_position
                    prev_box_locs = copy.deepcopy(state.boxes)

            num_delivered = 0
            next_box_to_deliver = boxes_todo[num_delivered]

            if not quit_signal:
                # Now find the actions to take to deliver the box
                robot_initial_position = state.robot_position
                deliver_actions = self._get_actions_from_policy( deliver_policy, robot_initial_position )

                if VISUALIZE_FLAG:
                    gui.total_actions_left = len(deliver_actions)

                if VERBOSE_FLAG:
                    print("Deliver actions: ")
                    for i in range(len(deliver_actions )):
                        print( deliver_actions[i])

                for action in deliver_actions:
                    if VERBOSE_FLAG:
                        state.print_to_console( self.fout )
                    state.update_according_to(action)

                    if VISUALIZE_FLAG:
                        gui.update(state, action, prev_loc, prev_box_locs)
                        quit_signal = gui.quit_signal
                        if quit_signal:
                            self.log('GUI received quit signal.')
                            break
                        prev_loc = state.robot_position
                        prev_box_locs = copy.deepcopy(state.boxes)

                    # check if new box has been delivered
                    delivered = state.get_boxes_delivered()
                    if len(delivered) > num_delivered:
                        last_box_delivered = delivered[-1]
                        if last_box_delivered == next_box_to_deliver:
                            num_delivered += 1
                            if num_delivered < len(boxes_todo):
                                next_box_to_deliver = boxes_todo[num_delivered]
                            else:
                                # all boxes delivered: end test
                                break
                        else:
                            # wrong box delivered: kill test
                            raise Exception('box delivered out of order: box {} delivered instead of box {}'.format(last_box_delivered,
                                                                                           next_box_to_deliver))

            if VERBOSE_FLAG:
                # print final state
                self.log('\n\n')
                self.log('Final State: ')
                state.print_to_console( self.fout )

            #Note, to receive credit, you must have deliverd all boxes.
            if num_delivered == len(boxes_todo):
               self.submission_score.put(state.get_total_cost())
            else:
               self.submission_score.put(float('inf')) 

        except Exception as err:
            if VERBOSE_FLAG:
                # very detailed stack trace - clutters everything up
                self.submission_error.put(traceback.format_exc())
            else:
                # slightly less cluttered output but the stack trace is much less informative
                self.submission_error.put(err)
            self.submission_score.put(float('inf'))

        self.logmsgs.put( truncate_output( self.fout.getvalue() ) )


class PartBTestCase(unittest.TestCase):
    """ Test Part B.
    """

    results = ['', 'PART B TEST CASE RESULTS']
    SCORE_TEMPLATE = "\n".join((
        "\n-----------",
        "Test Case {test_case}",
        "Output: {output}",
        "cost: {cost}  (benchmark cost {benchmark_cost})",
        "credit: {score:.2f}"
    ))
    FAIL_TEMPLATE = "\n".join((
        "\n-----------",
        "Test Case {test_case}",
        "Output: {output}",
        "Failed: {message}",
        "credit: 0"
    ))

    credit = []
    totalCredit = 0

    fout = None

    @classmethod
    def _log(cls, s):
        (cls.fout or sys.stdout).write( s + '\n')

    def setUp(self):
        """Initialize test setup.
        """
        if studentExc:
            self.credit.append( 0.0 )
            self.results.append( "exception on import: %s" % str(studentExc) )
            raise studentExc

        self.student_submission = Submission( fout = self.__class__.fout )

    def tearDown(self):
        self.__class__.totalCredit = sum(self.__class__.credit)

    @classmethod
    def tearDownClass(cls):
        """Save student results at conclusion of test.
        """
        # Prints results after all tests complete
        for line in cls.results:
            cls._log(line)
        cls._log("\n-----------")
        cls._log('\nTotal Credit: {:.2f}'.format(cls.totalCredit))


    def check_results(self, params):

        error_message = ''
        cost = float('inf')
        score = 0.0
        logmsg = ''

        if not self.student_submission.logmsgs.empty():
            logmsg = self.student_submission.logmsgs.get()

        if not self.student_submission.submission_score.empty():
            cost = self.student_submission.submission_score.get()

        score = float(params['benchmark_cost']) / float(cost)
        if score > 1:
            score = 1

        if not self.student_submission.submission_error.empty():
            error_message = self.student_submission.submission_error.get()
            self.results.append(self.FAIL_TEMPLATE.format(message=error_message, output = logmsg, **params))

        else:
            self.results.append(self.SCORE_TEMPLATE.format(cost=cost, score=score, output = logmsg, **params))

        self.credit.append(score)

        self._log('test case {} credit: {}'.format(params['test_case'], score))
        if error_message:
            self._log('{}'.format(error_message))

        self.assertFalse(error_message, error_message)

        # fail the test if score is less than 1
        self.assertGreaterEqual(score, 1.0)

    def run_with_params(self, params):
        """Run test case using desired parameters.

        Args:
            params(dict): a dictionary of test parameters.
        """

        if DEBUGGING_SINGLE_PROCESS:
            self.student_submission.execute_student_plan(params['test_case'],
                                                         params['warehouse'],
                                                         params['warehouse_cost'],
                                                         params['robot_init'],
                                                         params['todo'])
        else:
            test_process = mproc.Process(target=self.student_submission.execute_student_plan,
                                         args=(params['test_case'],
                                               params['warehouse'],
                                               params['warehouse_cost'],
                                               params['robot_init'],
                                               params['todo']))

        if DEBUGGING_SINGLE_PROCESS :

            # Note: no TIMEOUT is checked in this case so that debugging isn't 
            # inadvertently stopped

            self.check_results( params )

        else:

            logmsg = ''

            try:
                test_process.start()
                test_process.join(TIME_LIMIT)
            except Exception as exp:
                error_message = exp

            if test_process.is_alive():
                test_process.terminate()
                error_message = ('Test aborted due to timeout. ' +
                                'Test was expected to finish in fewer than {} second(s).'.format(TIME_LIMIT))
                if not self.student_submission.logmsgs.empty():
                    logmsg = self.student_submission.logmsgs.get()
                self.results.append(self.FAIL_TEMPLATE.format(message=error_message, output = logmsg, **params))

            else:

                self.check_results( params )
   
    def test_case_01(self):
        w = math.inf
        params = {'test_case': 1,
                  'warehouse': ['1..',
                                '.#.',
                                '..@'],
                  'warehouse_cost': [[3, 5, 2],
                                     [10, w, 2],
                                     [2, 10, 2]],
                  'todo': ['1'],
                  'robot_init':(0,2),
                  'benchmark_cost': 23}

        self.run_with_params(params)

    # Notice that we have included several extra test cases below.
    # You can uncomment one or more of these for extra tests.

    def test_case_02(self):
        w = math.inf
        params = {'test_case': 2,
                  'warehouse': ['1..',
                                '.#.',
                                '..@'],
                  'warehouse_cost': [[3, 25, 2],
                                     [10, w, 2],
                                     [2, 10, 2]],
                  'todo': ['1'],
                  'robot_init': (2, 1),
                  'benchmark_cost': 37}

        self.run_with_params(params)

    def test_case_03(self):
        w = math.inf
        params = {'test_case': 3,
                  'warehouse': ['##.####1',
                                '#.......',
                                '@.......'],
                  'warehouse_cost': [[w, w, 3, w, w, w, w, 12],
                                     [w, 8, 10, 2, 10, 4, 15, 8],
                                     [15, 10, 10, 10, 7, 10, 2, 10]],
                  'robot_init': (0, 2),
                  'todo': ['1'],
                  'benchmark_cost': 115}

        self.run_with_params(params)

    def test_case_04(self):
        w = math.inf
        params = {'test_case': 4,
                  'warehouse': ['.........#..........',
                                '...#.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, w, 10, 12, 93, 45, 30, 2, 3, 95, 2, 44],
                                     [82, 79, 61, w, 78, 59, 19, 11, 23, w, 91, 14, 1, 64, 62, 31, 8, 85, 69, 59],
                                     [0, 8, 76, w, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31, 83, 25],
                                     [58, 67, 85, w, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20],
                                     [9, 71, 27, 18, w, 3, 44, 93, 14, w, w, w, w, w, 67, 18, 85, 39, w, w],
                                     [58, 5, 53, 35, 84, 5, w, 22, 34, w, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44],
                                     [63, 43, 74, 59, 60, 5, w, 95, 60, w, 76, 21, 56, 0, 93, 94, 66, 56, 37, 35]],
                  'todo': ['1'],
                  'robot_init': (6, 19),
                  'benchmark_cost': 824}

        self.run_with_params(params)

    def test_case_05(self):
        w = math.inf
        params = {'test_case': 5,
                  'warehouse': ['.........#..........',
                                '####.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, w, 10, 12, 93, 45, 30, 2, 3, 95, 2, 44],
                                     [w, w, w, w, 78, 59, 19, 11, 23, w, 91, 14, 1, 64, 62, 31, 8, 85, 69, 59],
                                     [0, 8, 76, w, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31, 83, 25],
                                     [58, 67, 85, w, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20],
                                     [9, 71, 27, 18, w, 3, 44, 93, 14, w, w, w, w, w, 67, 18, 85, 39, w, w],
                                     [58, 5, 53, 35, 84, 5, w, 22, 34, w, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44],
                                     [63, 43, 74, 59, 60, 5, w, 95, 60, w, 76, 21, 56, 0, 93, 94, 66, 56, 37, 35]],
                  'todo': ['1'],
                  'robot_init': (0, 1),
                  'benchmark_cost': 577}

        self.run_with_params(params)

    def test_case_06(self):
        w = math.inf
        params = {'test_case': 6,
                  'warehouse': ['.........#..........',
                                '..##.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, w, 10, 12, 93, 45, 30, 2, 3, 95, 2, 44],
                                     [1, 37, w, w, 78, 59, 19, 11, 23, w, 91, 14, 1, 64, 62, 31, 8, 85, 69, 59],
                                     [0, 8, 76, w, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31, 83, 25],
                                     [58, 67, 85, w, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20],
                                     [9, 71, 27, 18, w, 3, 44, 93, 14, w, w, w, w, w, 67, 18, 85, 39, w, w],
                                     [58, 5, 53, 35, 84, 5, w, 22, 34, w, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44],
                                     [63, 43, 74, 59, 60, 5, w, 95, 60, w, 76, 21, 56, 0, 93, 94, 66, 56, 37, 35]],
                  'todo': ['1'],
                  'robot_init': (2, 19),
                  'benchmark_cost': 792}

        self.run_with_params(params)

    def test_case_07(self):
        w = math.inf
        params = {'test_case': 7,
                  'warehouse': ['.........#..........',
                                '..##.....#..........',
                                '1..#................',
                                '...#................',
                                '....#....#####....##',
                                '......#..#..........',
                                '......#..#...@......'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, w, 10, 12, 93, 45, 30, 2, 3, 95, 2, 44],
                                     [1, 37, w, w, 78, 59, 19, 11, 23, w, 91, 14, 1, 64, 62, 31, 8, 85, 69, 59],
                                     [0, 8, 76, w, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31, 83, 25],
                                     [58, 67, 85, w, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20],
                                     [9, 71, 27, 18, w, 3, 44, 93, 14, w, w, w, w, w, 67, 18, 85, 39, w, w],
                                     [58, 5, 53, 35, 84, 5, w, 22, 34, w, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44],
                                     [63, 43, 74, 59, 60, 5, w, 95, 60, w, 76, 21, 56, 0, 93, 94, 66, 56, 37, 35]],
                  'todo': ['1'],
                  'robot_init': (0, 8),
                  'benchmark_cost': 541}

        self.run_with_params(params)

    def test_case_08(self):
        w = math.inf
        params = {'test_case': 8,
                  'warehouse': ['............#...............',
                                '......#.....#...............',
                                '.....................#......',
                                '............................',
                                '..1...#.....................',
                                '............##########......',
                                '......#..#..#.........#.....',
                                '.........#..#....@....#.....',
                                '......#.....#.........#.....',
                                '............#.........#.....'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, 10, 12, 93, w, 45, 30, 2, 3, 95, 2, 44, 82, 79, 61, 78, 59, 19, 11, 23],
                                     [91, 14, 1, 64, 62, 31, w, 8, 85, 69, 59, 8, w, 76, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31],
                                     [83, 25, 58, 67, 85, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20, w, 9, 71, 27, 18, 3, 44],
                                     [93, 14, 67, 18, 85, 39, 58, 5, 53, 35, 84, 5, 22, 34, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44, 63, 43, 74, 59],
                                     [60, 5, 95, 60, 76, 21, w, 56, 93, 94, 66, 56, 37, 35, 15, 94, 23, 53, 55, 93, 15, 67, 13, 62, 48, 84, 32, 82],
                                     [24, 44, 13, 89, 89, 20, 74, 34, 19, 92, 41, 95, w, w, w, w, w, w, w, w, w, w, 57, 92, 9, 10, 50, 27],
                                     [6, 36, 4, 28, 64, 11, w, 89, 40, w, 39, 58, w, 8, 74, 32, 9, 88, 54, 25, 12, 50, w, 24, 90, 58, 64, 30],
                                     [46, 26, 65, 89, 53, 22, 74, 26, 38, w, 7, 45, w, 68, 19, 63, 93, 70, 60, 42, 17, 16, w, 6, 79, 21, 18, 69],
                                     [8, 91, 41, 21, 0, 85, w, 86, 7, 81, 11, 92, w, 18, 27, 5, 55, 50, 94, 41, 26, 86, w, 48, 35, 68, 80, 38],
                                     [54, 40, 87, 73, 19, 68, 11, 92, 33, 35, 52, 51, w, 72, 35, 67, 14, 89, 48, 35, 27, 38, w, 91, 75, 50, 6, 44]],
                  'todo': ['1'],
                  'robot_init': (1, 27),
                  'benchmark_cost': 1304}

        self.run_with_params(params)

    def test_case_09(self):
        w = math.inf
        params = {'test_case': 9,
                  'warehouse': ['............#...............',
                                '......#.....#...............',
                                '.....................#......',
                                '............................',
                                '..1...#.....................',
                                '............##########......',
                                '......#..#..#.........#.....',
                                '.........#..#....@....#.....',
                                '......#.....#.........#.....',
                                '............#.........#.....'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, 10, 12, 93, w, 45, 30, 2, 3, 95, 2, 44, 82, 79, 61, 78, 59, 19, 11, 23],
                                     [91, 14, 1, 64, 62, 31, w, 8, 85, 69, 59, 8, w, 76, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31],
                                     [83, 25, 58, 67, 85, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20, w, 9, 71, 27, 18, 3, 44],
                                     [93, 14, 67, 18, 85, 39, 58, 5, 53, 35, 84, 5, 22, 34, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44, 63, 43, 74, 59],
                                     [60, 5, 95, 60, 76, 21, w, 56, 93, 94, 66, 56, 37, 35, 15, 94, 23, 53, 55, 93, 15, 67, 13, 62, 48, 84, 32, 82],
                                     [24, 44, 13, 89, 89, 20, 74, 34, 19, 92, 41, 95, w, w, w, w, w, w, w, w, w, w, 57, 92, 9, 10, 50, 27],
                                     [6, 36, 4, 28, 64, 11, w, 89, 40, w, 39, 58, w, 8, 74, 32, 9, 88, 54, 25, 12, 50, w, 24, 90, 58, 64, 30],
                                     [46, 26, 65, 89, 53, 22, 74, 26, 38, w, 7, 45, w, 68, 19, 63, 93, 70, 60, 42, 17, 16, w, 6, 79, 21, 18, 69],
                                     [8, 91, 41, 21, 0, 85, w, 86, 7, 81, 11, 92, w, 18, 27, 5, 55, 50, 94, 41, 26, 86, w, 48, 35, 68, 80, 38],
                                     [54, 40, 87, 73, 19, 68, 11, 92, 33, 35, 52, 51, w, 72, 35, 67, 14, 89, 48, 35, 27, 38, w, 91, 75, 50, 6, 44]],
                  'todo': ['1'],
                  'robot_init': (9, 17),
                  'benchmark_cost': 1479}

        self.run_with_params(params)

    def test_case_10(self):
        w = math.inf
        params = {'test_case': 10,
                  'warehouse': ['............#...............',
                                '......#.....#...............',
                                '.....................#......',
                                '............................',
                                '......#.....................',
                                '............##########......',
                                '......#..#..#.........#.....',
                                '.........#..#....@....#.....',
                                '......#.....#....1....#.....',
                                '............#.........#.....'],
                  'warehouse_cost': [[94, 56, 14, 0, 11, 74, 4, 85, 88, 10, 12, 93, w, 45, 30, 2, 3, 95, 2, 44, 82, 79, 61, 78, 59, 19, 11, 23],
                                     [91, 14, 1, 64, 62, 31, w, 8, 85, 69, 59, 8, w, 76, 86, 11, 65, 74, 5, 34, 71, 8, 82, 38, 61, 45, 34, 31],
                                     [83, 25, 58, 67, 85, 2, 65, 9, 0, 42, 18, 90, 60, 84, 48, 21, 6, 9, 75, 63, 20, w, 9, 71, 27, 18, 3, 44],
                                     [93, 14, 67, 18, 85, 39, 58, 5, 53, 35, 84, 5, 22, 34, 19, 38, 19, 94, 59, 5, 72, 49, 92, 44, 63, 43, 74, 59],
                                     [60, 5, 95, 60, 76, 21, w, 56, 93, 94, 66, 56, 37, 35, 15, 94, 23, 53, 55, 93, 15, 67, 13, 62, 48, 84, 32, 82],
                                     [24, 44, 13, 89, 89, 20, 74, 34, 19, 92, 41, 95, w, w, w, w, w, w, w, w, w, w, 57, 92, 9, 10, 50, 27],
                                     [6, 36, 4, 28, 64, 11, w, 89, 40, w, 39, 58, w, 8, 74, 32, 9, 88, 54, 25, 12, 50, w, 24, 90, 58, 64, 30],
                                     [46, 26, 65, 89, 53, 22, 74, 26, 38, w, 7, 45, w, 68, 19, 63, 93, 70, 60, 42, 17, 16, w, 6, 79, 21, 18, 69],
                                     [8, 91, 41, 21, 0, 85, w, 86, 7, 81, 11, 92, w, 18, 27, 5, 55, 50, 94, 41, 26, 86, w, 48, 35, 68, 80, 38],
                                     [54, 40, 87, 73, 19, 68, 11, 92, 33, 35, 52, 51, w, 72, 35, 67, 14, 89, 48, 35, 27, 38, w, 91, 75, 50, 6, 44]],
                  'todo': ['1'],
                  'robot_init': (7, 17),
                  'benchmark_cost': 138}

        self.run_with_params(params)


# Only run all of the test automatically if this file was executed from the command line.
# Otherwise, let Nose/py.test do it's own thing with the test cases.
if __name__ == "__main__":
    if studentExc:
        print(studentExc)
        print('score: 0')
    else:
        student_id = who_am_i()
        if student_id:
            PartBTestCase.fout = sys.stdout
            unittest.main()
        else:
            print("Student ID not specified.  Please fill in 'whoami' variable.")
            print('score: 0')
